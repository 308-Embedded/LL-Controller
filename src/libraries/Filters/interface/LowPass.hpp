// generated by gemini3
#pragma once

#include <cmath>
#include <numbers>

template <typename Scalar, int SampleRate, int Order>
class IIRLowPassFilter {
    static_assert(Order == 1 || Order == 2, "Only Order 1 or 2 is supported.");

public:
    IIRLowPassFilter() {
        s1 = 0;
        s2 = 0;
    }

    Scalar filter(const Scalar x) {
        Scalar out = b0 * x + s1;
        
        if constexpr (Order == 1) {
            s1 = b1 * x - a1 * out;
        } else {
            s1 = b1 * x - a1 * out + s2;
            s2 = b2 * x - a2 * out;
        }
        
        return out;
    }

    void set_params(const Scalar cutoff_freq) {
        const Scalar resonance = std::numbers::sqrt2_v<Scalar>; 
        const Scalar wc = 2 * std::numbers::pi_v<Scalar> * cutoff_freq / SampleRate;
        const Scalar c = std::tan(wc * 0.5);

        if constexpr (Order == 1) {
            a1 = (c - 1) / (c + 1);
            b0 = c / (c + 1);
            b1 = b0;
        } else {
            const Scalar c2 = c * c;
            const Scalar root2c = resonance * c;
            const Scalar norm = 1 / (1 + root2c + c2);
            
            b0 = c2 * norm;
            b1 = 2 * b0;
            b2 = b0;
            a1 = 2 * (c2 - 1) * norm;
            a2 = (1 - root2c + c2) * norm;
        }
    }

private:
    Scalar s1{0}, s2{0}; 
    Scalar b0{0}, b1{0}, b2{0}, a1{0}, a2{0};
};