// generated by gemini
#include "ringbuf.h"
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define MIN(a, b) ((a) < (b) ? (a) : (b))

// Check if a number is a power of 2
#define IS_POWER_OF_TWO(x) ((x) > 0 && (((x) & ((x) - 1)) == 0))

// Rounds up to the next power of 2
static int roundup_power_of_two(int v) {
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
}

void ringbuf_init(ringbuf_t *rb, void *buffer, int capacity) {
    if (capacity <= 0) {
        return;
    }

    if (!IS_POWER_OF_TWO(capacity)) {
        capacity = roundup_power_of_two(capacity);
    }

    rb->buffer = buffer;
    rb->capacity = capacity;
    rb->head = 0;
    rb->tail = 0;
}

int ringbuf_capacity(const ringbuf_t *rb) {
    return rb->capacity;
}

int ringbuf_bytes_used(const ringbuf_t *rb) {
    return rb->head - rb->tail;
}

int ringbuf_bytes_free(const ringbuf_t *rb) {
    return rb->capacity - (rb->head - rb->tail);
}

int ringbuf_is_full(const ringbuf_t *rb) {
    return ringbuf_bytes_free(rb) == 0;
}

int ringbuf_is_empty(const ringbuf_t *rb) {
    return ringbuf_bytes_used(rb) == 0;
}

const void *ringbuf_tail(const ringbuf_t *rb) {
    return rb->buffer + (rb->tail & (rb->capacity - 1));
}

const void *ringbuf_head(const ringbuf_t *rb) {
    return rb->buffer + (rb->head & (rb->capacity - 1));
}

static void ringbuf_memcpy_from(void * restrict dst, const ringbuf_t * restrict rb, int count) {
    const int tail_idx = rb->tail & (rb->capacity - 1);
    const int bytes_till_end = rb->capacity - tail_idx;
    
    if (count > bytes_till_end) {
        memcpy(dst, rb->buffer + tail_idx, bytes_till_end);
        memcpy((uint8_t*)dst + bytes_till_end, rb->buffer, count - bytes_till_end);
    } else {
        memcpy(dst, rb->buffer + tail_idx, count);
    }
}

static void ringbuf_memcpy_to(ringbuf_t * restrict rb, const void * restrict src, int count) {
    const int head_idx = rb->head & (rb->capacity - 1);
    const int bytes_till_end = rb->capacity - head_idx;
    
    if (count > bytes_till_end) {
        memcpy(rb->buffer + head_idx, src, bytes_till_end);
        memcpy(rb->buffer, (const uint8_t*)src + bytes_till_end, count - bytes_till_end);
    } else {
        memcpy(rb->buffer + head_idx, src, count);
    }
}

int ringbuf_push(ringbuf_t * restrict rb, const void * restrict src, int count) {
    if (count <= 0) {
        return 0;
    }
    int bytes_to_write = MIN(count, ringbuf_bytes_free(rb));
    if(bytes_to_write == 0) return 0;

    ringbuf_memcpy_to(rb, src, bytes_to_write);
    
    rb->head += bytes_to_write;
    return bytes_to_write;
}

int ringbuf_pop(ringbuf_t * restrict rb, void * restrict dst, int count) {
    if (count <= 0) {
        return 0;
    }
    int bytes_to_read = MIN(count, ringbuf_bytes_used(rb));
    if(bytes_to_read == 0) return 0;

    ringbuf_memcpy_from(dst, rb, bytes_to_read);

    rb->tail += bytes_to_read;
    return bytes_to_read;
}
int ringbuf_peek(const ringbuf_t * restrict rb, void * restrict dst, int count) {
    if (count <= 0) {
        return 0;
    }
    int bytes_to_read = MIN(count, ringbuf_bytes_used(rb));
    if(bytes_to_read == 0) return 0;
    
    ringbuf_memcpy_from(dst, rb, bytes_to_read);

    return bytes_to_read;
}
